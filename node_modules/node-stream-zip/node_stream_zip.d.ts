/// <reference types="node" />

declare namespace StreamZip {
    interface StreamZipOptions {
        /**
         * File to read
         * @default undefined
         */
<<<<<<< HEAD
        file?: string
=======
        file?: string;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * Alternatively, you can pass fd here
         * @default undefined
         */
<<<<<<< HEAD
        fd?: number,
=======
        fd?: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * You will be able to work with entries inside zip archive,
         * otherwise the only way to access them is entry event
         * @default true
         */
<<<<<<< HEAD
        storeEntries?: boolean
=======
        storeEntries?: boolean;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * By default, entry name is checked for malicious characters, like ../ or c:\123,
         * pass this flag to disable validation error
         * @default false
         */
<<<<<<< HEAD
        skipEntryNameValidation?: boolean
=======
        skipEntryNameValidation?: boolean;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * Filesystem read chunk size
         * @default automatic based on file size
         */
<<<<<<< HEAD
        chunkSize?: number
=======
        chunkSize?: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad
    }

    interface ZipEntry {
        /**
         * file name
         */
<<<<<<< HEAD
        name: string
=======
        name: string;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * true if it's a directory entry
         */
<<<<<<< HEAD
        isDirectory: boolean
=======
        isDirectory: boolean;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * true if it's a file entry, see also isDirectory
         */
<<<<<<< HEAD
        isFile: boolean
=======
        isFile: boolean;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * file comment
         */
<<<<<<< HEAD
        comment: string
=======
        comment: string;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * if the file is encrypted
         */
<<<<<<< HEAD
        encrypted: boolean
=======
        encrypted: boolean;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * version made by
         */
<<<<<<< HEAD
        verMade: number
=======
        verMade: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * version needed to extract
         */
<<<<<<< HEAD
        version: number
=======
        version: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * encrypt, decrypt flags
         */
<<<<<<< HEAD
        flags: number
=======
        flags: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * compression method
         */
<<<<<<< HEAD
        method: number
=======
        method: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * modification time
         */
<<<<<<< HEAD
        time: number
=======
        time: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * uncompressed file crc-32 value
         */
<<<<<<< HEAD
        crc: number
=======
        crc: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * compressed size
         */
<<<<<<< HEAD
        compressedSize: number
=======
        compressedSize: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * uncompressed size
         */
<<<<<<< HEAD
        size: number
=======
        size: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * volume number start
         */
<<<<<<< HEAD
        diskStart: number
=======
        diskStart: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * internal file attributes
         */
<<<<<<< HEAD
        inattr: number
=======
        inattr: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * external file attributes
         */
<<<<<<< HEAD
        attr: number
=======
        attr: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

        /**
         * LOC header offset
         */
<<<<<<< HEAD
        offset: number
=======
        offset: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad
    }
}

type StreamZipOptions = StreamZip.StreamZipOptions;
type ZipEntry = StreamZip.ZipEntry;

<<<<<<< HEAD
=======
declare class StreamZipAsync {
    constructor(config: StreamZipOptions);

    entriesCount: Promise<number>;
    comment: Promise<string>;

    entry(name: string): Promise<ZipEntry | undefined>;
    entries(name: string): Promise<{ [name: string]: ZipEntry }>;
    entryData(entry: string | ZipEntry): Promise<Buffer>;
    stream(entry: string | ZipEntry): Promise<NodeJS.ReadableStream>;
    extract(entry: string | ZipEntry | null, outPath: string): Promise<number | undefined>;

    on(event: 'entry', handler: (entry: ZipEntry) => void): void;
    on(event: 'extract', handler: (entry: ZipEntry, outPath: string) => void): void;

    close(): Promise<void>;
}

>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad
declare class StreamZip {
    constructor(config: StreamZipOptions);

    /**
     * number of entries in the archive
     */
<<<<<<< HEAD
    entriesCount: number
=======
    entriesCount: number;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad

    /**
     * archive comment
     */
<<<<<<< HEAD
    comment: string

    on(event: 'error', handler: (error: any) => void): void
    on(event: 'entry', handler: (entry: ZipEntry) => void): void
    on(event: 'ready', handler: () => void): void
    on(event: 'extract', handler: (entry: ZipEntry, outPath: string) => void): void

    entry(name: string): ZipEntry | undefined

    entries(): { [name: string]: ZipEntry }

    stream(entry: string | ZipEntry, callback: (err: any | null, stream?: NodeJS.ReadableStream) => void): void

    entryDataSync(entry: string | ZipEntry): Buffer

    openEntry(entry: string | ZipEntry, callback: (err: any | null, entry?: ZipEntry) => void, sync: boolean): void

    extract(entry: string | ZipEntry | null, outPath: string, callback: (err?: any) => void): void

    close(callback?: (err?: any) => void): void
=======
    comment: string;

    on(event: 'error', handler: (error: any) => void): void;
    on(event: 'entry', handler: (entry: ZipEntry) => void): void;
    on(event: 'ready', handler: () => void): void;
    on(event: 'extract', handler: (entry: ZipEntry, outPath: string) => void): void;

    entry(name: string): ZipEntry | undefined;

    entries(): { [name: string]: ZipEntry };

    stream(
        entry: string | ZipEntry,
        callback: (err: any | null, stream?: NodeJS.ReadableStream) => void
    ): void;

    entryDataSync(entry: string | ZipEntry): Buffer;

    openEntry(
        entry: string | ZipEntry,
        callback: (err: any | null, entry?: ZipEntry) => void,
        sync: boolean
    ): void;

    extract(
        entry: string | ZipEntry | null,
        outPath: string,
        callback: (err?: any, res?: number) => void
    ): void;

    close(callback?: (err?: any) => void): void;

    static async: typeof StreamZipAsync;
>>>>>>> 64e5a878e639053ebd41b0338fb1e758bb115dad
}

export = StreamZip;
